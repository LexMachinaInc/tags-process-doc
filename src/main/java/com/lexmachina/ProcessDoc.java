package com.lexmachina;

import java.util.Arrays;
import java.util.List;

import com.querydsl.core.Tuple;
import com.querydsl.sql.SQLQuery;

import com.lexmachina.domain.QDcCase;
import com.lexmachina.domain.QDcDocketEntry;
import com.lexmachina.domain.QDcDocument;
import com.lexmachina.domain.QDcDocumentText;

public class ProcessDoc {

  // NOTE: Q* classes are generated by querydsl, must run maven build to generate
  // (and then re-sync with IDE if using one)
  private static QDcDocumentText documentTextT = QDcDocumentText.dcDocumentText;
  private static QDcDocument documentT = QDcDocument.dcDocument;
  private static QDcDocketEntry docketEntryT = QDcDocketEntry.dcDocketEntry;
  private static QDcCase caseT = QDcCase.dcCase;

  public static void main(String[] args) {
    DBReader dbReader = new DBReader();

    final int CASE_ID = 2001141372;
    final int DOCKET_ENTRY_ID = 2035035260;

    // subquery to get the document_text id of the highest priority document text for a given doc id
    SQLQuery<Integer> subQuery = dbReader.queryFactory().query()
        .select(documentTextT.id)
        .from(documentTextT)
        .orderBy(documentTextT.priority.desc(), documentTextT.timestamp.desc())
        .limit(1);

    // TODO: query gets all document text for all documents on a docket entry; need to adjust to get
    // all document text for all documents on a case
    SQLQuery<Tuple> query = dbReader.queryFactory().query()
        .select(documentT.id, documentTextT.id, documentTextT.rawText)
        .from(documentTextT)
        .join(documentT).on(documentTextT.documentId.eq(documentT.id))
        .where(documentT.docketEntryId.eq(DOCKET_ENTRY_ID))
        .where(documentTextT.id.eq(subQuery.where(documentTextT.documentId.eq(documentT.id))));

    //System.out.println("query = " + query.getSQL().getSQL());

    List<Tuple> tuples = query.fetch();

    // TODO: counts number of "plaintiff" words; need to change to collect lines that match
    // "Attorneys for <blah>" or "Counsel for <blah>"

    long plaintiffCount = tuples.stream()
        .peek(t -> System.out.println("docId = " + t.get(documentT.id)))
        .map(t -> t.get(documentTextT.rawText))
        .flatMap(s -> Arrays.stream(s.split("\\s+")))
        .filter(s -> s.equalsIgnoreCase("plaintiff"))
        .count();

    System.out.println("plaintiffCount = " + plaintiffCount);

  }
}
